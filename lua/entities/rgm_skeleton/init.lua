AddCSLuaFile("shared.lua");
AddCSLuaFile("cl_init.lua");
include("shared.lua");

util.AddNetworkString("rgm_skeleton_sync");

function ENT:Initialize()

	self.BaseClass.Initialize(self);

end

function ENT:SetEntity(ent)
	self:SetNWEntity("Entity", ent);
end

function ENT:BuildNodes()

	local ent = self:GetEntity();
	
	if ent:GetClass() == "prop_ragdoll" then

		-- TODO merge physbone and bone creation
		
		--Physical bones
		for p = 0, ent:GetPhysicsObjectCount() - 1 do

			local pp = rgm.GetPhysBoneParent(ent, p);

			local pn = nil;
			if pp then
				pn = self:GetNodeForPhysBone(pp);
			end

			self:CreateNode(pn, RgmNodeType.PhysBone, p);

		end

		for b = 0, ent:GetBoneCount() - 1 do

			local p = rgm.BoneToPhysBone(ent, b);

			if p == -1 then

				local pn = nil;
				local bp = ent:GetBoneParent(b);

				if bp ~= -1 then
					local pp = rgm.GetPhysBoneParent(ent, bp);
					if pp == -1 then
						pn = self:GetNodeForBone(bp);
					end
				end

				self:CreateNode(pn, RgmNodeType.Bone, b);

			end

		end
		
	else
		--Create only root node when not a ragdoll.
		self:CreateNode(nil, RgmNodeType.Origin, 0);
	end

	net.Start("rgm_skeleton_sync");

	net.WriteEntity(self);
	net.WriteTable(self.m_Nodes);

	net.Send(player.GetAll());

end

---
-- Create a new node for this skeleton. The node's ID is generated by inserting it
-- to the end of the node table.
-- The first argument is the parent node of the created node, the second is NodeType,
-- the third is the bone ID of the node.
---
function ENT:CreateNode(parent, type, boneId)
	
	local node = ents.Create("rgm_skeleton_node");

	local id = table.insert(self.m_Nodes, node);

	node:Spawn();
	node:Setup(self, id, parent, type, boneId);
	
	return node;
	
end

---
-- Create and attach a constraint to this skeleton,
-- affecting the given nodes of this skeleton.
---
function ENT:CreateConstraint(nodes)

	for _, node in pairs(nodes) do
		if not table.HasValue(self.m_Nodes, node) then
			error("CreateConstraint: Skeleton of entity " .. self:GetEntity()
				.. " does not contain given node");
		end
	end

	local c = ents.Create("rgm_constraint");
	c:Spawn();
	c:Setup(nodes);

	table.insert(self.m_Constraints, c);

	self:SendMessage("Sync", self.m_Nodes, self.m_Constraints);

end

---
-- Called by rgm_manipulator when this skeleton is grabbed
-- No need to call OnGrab on nodes, manipulator calls the grabbed node's OnGrab
---
function ENT:OnGrab()

	self:Lock();

end

---
-- Called by rgm_manipulator when this skeleton is released
-- No need to call OnRelease on nodes, manipulator calls the released node's OnRelease
---
function ENT:OnRelease()

	self:Unlock();

end

---
-- Restore node positions from previously stored data
---
function ENT:Restore()

	if not self.m_RestoreData then return false; end

	for i, node in pairs(self.m_Nodes) do

		local data = self.m_RestoreData[i];

		node:SetPosAng(data.pos, data.ang);

	end

	return true;

end

---
-- Store node positions and angles for later restoration
---
function ENT:SetRestorePoint()
	
	self.m_RestoreData = {};

	for i, node in pairs(self.m_Nodes) do

		local pos, ang = node:GetPosAng();

		self.m_RestoreData[i] = { pos = pos, ang = ang };

	end

end

---
-- Lock the positions of the actual entity into the skeleton's positions.
---
function ENT:Lock()
	
	for _, node in pairs(self.m_Nodes) do
		node:Lock();
	end
	
	self:SetNWBool("Locked", true);
	
end

---
-- Unlock the positions of the actual entity; makes the skeleton follow the entity.
---
function ENT:Unlock()
	
	for _, node in pairs(self.m_Nodes) do
		node:Unlock();
	end

	self:SetNWBool("Locked", false);
	
end

---
-- Update position of the target entity to the skeleton's nodes.
-- This does nothing if the skeleton is unlocked.
---
function ENT:Update()

	if not self:IsLocked() then return; end
	
	for _, node in pairs(self.m_Nodes) do
		node:Update();
	end

	for _, c in pairs(self.m_Constraints) do
		c:Update();
	end

end